Imports System.IO
Imports System.IO.Ports
Imports System.Threading
Imports System.Text
Imports System.Timers

Public Class ClientSCS
   Implements IClient
    ' This Class handles all PTC II TNCs (PTCII, IIe, IIex, IIpro, IIusb, DR-7800) for both Packet and Pactor connections

   Private Structure ConnectedCall
      Public Callsign As String                    ' Callsign of the connected call
      Public ConnectionID As Integer               ' The connection ID (unique)
      Public PendingDisconnect As Boolean          ' Flag to indicate a pending disconnect on this Connection 
      Public Port As Integer                       ' Port number of the connected call
      Public StartDisconnect As Date               ' Time disconnect countdown started to delay disconnect 
   End Structure

   '  Integer
   Private intConnectScriptPtr As Integer = -1     ' Pointer to the active connect script line, -1 disables scripting
   Private intScriptTimer As Integer = -1          ' Used to time out a stuck connection script
   Private intConnectTimer As Integer              ' For Pactor connect timeouts
   Private intActivityTimer As Integer             ' For activity timeouts
   Private intBytesSentCount As Integer            ' Holds last bytes sent count

   ' Bytes
   Private bytLink As Byte                         ' Connected link state
   Private bytMode As Byte                         ' 0 Standby, &H20 ARQ, &H40 FEC, &H70 Busy
   Private bytDirection As Byte                    ' True for ISS else False
   Private blnSendingID As Boolean                 ' Set while an FEC ID is being sent
   Private Shared blnDoFECId As Boolean            ' Set at end of a successful link or unsuccessful selcal

   '  Strings
   Private strCommandReply As String               ' String reply from a command
   Private ConnectScript() As String               ' An array of connection script entries
   Private strStatus As String                     ' Holds plain language status

   '  Boolean
   Private blnHostMode As Boolean                  ' Indicates TNC in host mode
   Private blnCommandReply As Boolean              ' Flag indicating reply received TNC was a command
   Private blnAutomaticConnect As Boolean          ' Flag used to indicate if connection was initiated automatically
   Private blnNoIdentification As Boolean          ' Flag set to inhibit FEC Id
   Private blnWaitingForManualConnect As Boolean
   Private blnNormalDisconnect As Boolean
   Private blnIDSending As Boolean                 ' Flag to indicate FEC ID is being sent
   Private blnStandby As Boolean                   ' Flag used to signal standby status used in FEC ID
   Private blnDisconnectProcessed As Boolean       ' Flag used to keep from processing multiple disconnects

   '  Objects and classes 
   Private objProtocol As ProtocolInitial          ' Instance of the message protocol handler
   Private stcConnectedCall As ConnectedCall       ' Details of a connected link
   Private WithEvents objHostPort As SCSHostPort   ' Instance of the SCS host mode port

   ' Enums and Structures
   Private enmState As ELinkStates = ELinkStates.Undefined

   Public Sub Abort() Implements IClient.Abort
      ' Closes the channel immediately...

      If enmState <> ELinkStates.Connected Then
         Close()
         Return
      End If

      blnNoIdentification = True

      If objHostPort IsNot Nothing Then
         SendCommand("D", 31) ' Normal disconnect
         Thread.Sleep(2000)
         objHostPort.Close()
         objHostPort = Nothing
      End If
      enmState = ELinkStates.LinkFailed
      Close()
   End Sub ' Abort

   Public Function Close() As Boolean Implements IClient.Close
      ' Closes the channel and put TNC into known state.
      ' Always call this method before the instance goes out of scope...

      Static blnClosing As Boolean
      If blnClosing Then Return True
      blnClosing = True

      If Not (enmState = ELinkStates.Disconnected Or _
         enmState = ELinkStates.LinkFailed Or enmState = ELinkStates.NoSerialPort) Then
         ImmediateDisconnect()
      End If

      Try
         queChannelDisplay.Enqueue("G*** Closing " & stcSelectedChannel.ChannelName & " at " & TimestampEx())

         If objRadioControl IsNot Nothing Then ' Shut down the radio control and free the serial port
            objRadioControl.Close()
            objRadioControl = Nothing
         End If

         If objHostPort IsNot Nothing AndAlso objHostPort.HostState = SCSHostPort.HostModeState.HostMode Then
            ' Wait for all serial data to be sent before closing serial port...
            Dim dttStartClose As Date = Now
            While Now.Subtract(dttStartClose).TotalMilliseconds < 500 And blnSendingID
               Thread.Sleep(100)
            End While
            objHostPort.Close()
            objHostPort = Nothing
         End If

         If objProtocol IsNot Nothing Then
            objProtocol.CloseProtocol()
            objProtocol = Nothing
         End If
      Catch
         Logs.Exception("[PTCIIClient.Close] " & Err.Description)
      End Try

      If Not IsNothing(objHostPort) Then
         objHostPort.Close()
         objHostPort = Nothing
      End If

      queStateDisplay.Enqueue("")
      queStatusDisplay.Enqueue("Idle")
      queRateDisplay.Enqueue("------")
      blnClosing = False
      blnChannelActive = False
      Return True
   End Function ' Close 

   Public Function Connect(ByVal blnAutomatic As Boolean) As Boolean Implements IClient.Connect
      '  Handles new connection...

      If blnPactorDialogResuming = False Then queChannelDisplay.Enqueue(CLEAR)
      Dim strVia As String = ""
      Dim strTarget As String = stcSelectedChannel.RemoteCallsign
      blnAutomaticConnect = blnAutomatic
      If enmState <> ELinkStates.Initialized Then
         Try
            If OpenSerialPort() = False Then
               enmState = ELinkStates.NoSerialPort
               Return False
            End If
         Catch
            enmState = ELinkStates.NoSerialPort
            Return False
         End Try

         Try
            If Not InitializeTheTNC() Then
               enmState = ELinkStates.LinkFailed
               Me.Close()
               Return False
            Else
               enmState = ELinkStates.Initialized
            End If
         Catch
            Logs.Exception("[PTCIIClient.Connect B] " & Err.Description)
         End Try
      End If

      Try
         ' Modified to work for Pactor and Packet...
         If stcSelectedChannel.RDOControl = "Serial" Or stcSelectedChannel.RDOControl = "Via PTCII" Then
            objSCSClient = Me
            If IsNothing(objRadioControl) Then
               If stcSelectedChannel.RDOModel.StartsWith("Kenwood") Then
                  objRadioControl = New RadioKenwood
               ElseIf stcSelectedChannel.RDOModel.StartsWith("Icom") Then
                  objRadioControl = New RadioIcom
               ElseIf stcSelectedChannel.RDOModel.StartsWith("Yaesu") Then
                  objRadioControl = New RadioYaesu
               ElseIf stcSelectedChannel.RDOControl = "Serial" And stcSelectedChannel.RDOModel.StartsWith("Micom") Then
                  objRadioControl = New RadioMicom
               Else
                  blnNoIdentification = True
                  queChannelDisplay.Enqueue("R*** Failure setting Radio control for radio " & stcSelectedChannel.RDOModel)
                  Return False
               End If
               If Not objRadioControl.InitializeSerialPort(stcSelectedChannel) Then
                  blnNoIdentification = True
                  queChannelDisplay.Enqueue("R*** Failure initializing Radio Control")
                  Logs.Exception("[PTCIIClient.Connect C] Failure initializing Radio Control")
                  Return False
               End If
            End If
         End If
      Catch
         Logs.Exception("[PTCIIClient.Connect D] " & Err.Description)
      End Try

      Try
         If stcSelectedChannel.ChannelType = EChannelModes.PacketTNC Then
            SendCommand("#ST 0", 31)
            ' note the followig is needed to set the packet call sign ....the PAC MYCALL does not appear to work correctly
            'SendCommand("#MYCALL " & SiteCallsign, 31)
            'SendCommand("#PAC MYCALL " & SiteCallsign, 31)
            SendCommand("I" & stcSelectedChannel.TNCPort.ToString & ":" & SiteCallsign, stcSelectedChannel.TNCPort)
         ElseIf stcSelectedChannel.ChannelType = EChannelModes.PactorTNC Then
            SendCommand("#ST 2", 31)
            SendCommand("#MYCALL " & SiteCallsign, 31)
            SendCommand("#FSKA " & stcSelectedChannel.TNCFSKLevel.ToString, 31)
            SendCommand("#PSKA " & stcSelectedChannel.TNCPSKLevel.ToString, 31)
         End If
      Catch
         Logs.Exception("[PTCIIClient.Connect E] " & Err.Description)
      End Try

      Dim strTemp As String
      If stcSelectedChannel.ChannelType = EChannelModes.PacketTNC Then ' This handle packet connections
         Try
            If Not IsNothing(objRadioControl) Then objRadioControl.SetParameters(stcSelectedChannel)
            If Not IsNothing(ConnectScript) AndAlso ConnectScript.Length > 0 Then ' TODO: needs testing
               If RunScript(strVia, strTarget) Then ' Activates scripting, modifies sVia and sTarget
                  stcConnectedCall.Callsign = strTarget
                  strTemp = "C " & stcSelectedChannel.TNCPort.ToString & ":" & strTarget & strVia
                  ' Set for 60 second timeout...
                  intConnectTimer = 60
               Else
                  queChannelDisplay.Enqueue("R*** Script Error - ending connection")
                  blnChannelActive = False
                  enmState = ELinkStates.LinkFailed
                  objSelectedClient = Nothing
                  Return False
               End If
            Else
               ' Set for 60 second timeout...
               intConnectTimer = 60
               queRateDisplay.Enqueue("Linking")
               queChannelDisplay.Enqueue("G*** Starting Packet connection to " & stcSelectedChannel.RemoteCallsign & " on port " & stcSelectedChannel.TNCPort.ToString)
               strTemp = "C " & stcSelectedChannel.TNCPort.ToString & ":" & stcSelectedChannel.RemoteCallsign
            End If
         Catch
            Logs.Exception("[PTCIIClient.Connect F] " & Err.Description)
         End Try
      ElseIf stcSelectedChannel.ChannelType = EChannelModes.PactorTNC Then
         Try
            If (Not IsNumeric(stcSelectedChannel.RDOCenterFrequency.Replace(" (p3)", ""))) Or _
               (stcSelectedChannel.RemoteCallsign.Trim = "") Or Not blnAutomaticConnect Then

               ' This handles manual pactor connections or unspecified automatic channels...
               If dlgPactorConnect IsNot Nothing Then
                  dlgPactorConnect.Close()
                  dlgPactorConnect = Nothing
               End If

               blnWaitingForManualConnect = True
               If IsNothing(dlgPactorConnect) Then
                  If stcEditedSelectedChannel.RemoteCallsign <> "" Then
                     dlgPactorConnect = New DialogPactorConnect(Me, stcEditedSelectedChannel)
                  Else
                     dlgPactorConnect = New DialogPactorConnect(Me, stcSelectedChannel)
                  End If
               End If

               dlgPactorConnect.ShowDialog()
               blnWaitingForManualConnect = False
               If dlgPactorConnect.DialogResult = DialogResult.Cancel Then
                  Main.Refresh()
                  blnNoIdentification = True
                  If Not IsNothing(objProtocol) Then
                     objProtocol.LinkStateChange(EConnection.Disconnected)
                     objProtocol = Nothing
                  End If
                  dlgPactorConnect.Close()
                  dlgPactorConnect = Nothing
                  blnNoIdentification = True
                  enmState = ELinkStates.LinkFailed
                  Return False
               End If

               ' This updates the channel parameters...
               dlgPactorConnect.UpdateChannelProperties(stcSelectedChannel)
               dlgPactorConnect.Close()
               dlgPactorConnect = Nothing
               If Not blnPactorDialogResuming Then stcEditedSelectedChannel = Nothing
            Else
               ' Set the radio parameters for an automatic channel...
               If Not IsNothing(objRadioControl) Then objRadioControl.SetParameters(stcSelectedChannel)

               If stcSelectedChannel.TNCBusyHold Then
                  ' The following waits up to 30 sec for a 6 second clear channel before starting an auto forward...
                  blnWaitingForManualConnect = True
                  queChannelDisplay.Enqueue("G*** Waiting for clear channel condition...")

                  Dim intClearChannelMonitor As Integer
                  Dim dttClearChannelWait As Date = Now.AddSeconds(30)
                  Do
                     If dttClearChannelWait < Now Then Exit Do
                     Thread.Sleep(100)
                     Poll()
                     If strStatus <> "Channel Busy" Then intClearChannelMonitor += 1
                     If intClearChannelMonitor > 60 Then Exit Do
                  Loop
                  blnWaitingForManualConnect = False
                  If intClearChannelMonitor <= 60 Then
                     queChannelDisplay.Enqueue("R*** Channel busy - autoforwarding ended")
                     blnNoIdentification = True
                     enmState = ELinkStates.LinkFailed
                     Return False
                  End If
               End If
            End If
         Catch
            Logs.Exception("[PTCIIClient.Connect G] " & Err.Description)
         End Try

         Try
            queRateDisplay.Enqueue("Linking")
            queChannelDisplay.Enqueue("G*** Calling " & _
               stcSelectedChannel.RemoteCallsign & " on " & stcSelectedChannel.RDOCenterFrequency & " KHz")
            strTemp = "C " & stcSelectedChannel.RemoteCallsign
            ' intConnectTimer = CInt(Math.Max(15, 7 * stcChannel.FrequenciesScanned)) ' Set for 15 seconds min or 7 sec/freq
            intConnectTimer = 60
            objHostPort.blnISS = True  ' Precondition to ISS 
            blnIDSending = False
            blnNoIdentification = False
            blnDisconnectProcessed = False
         Catch
            Logs.Exception("[PTCIIClient.Connect H] " & Err.Description)
         End Try
      End If

      Try
         SendCommand(strTemp, stcSelectedChannel.TNCPort)
         blnNormalDisconnect = False
         blnDisconnectProcessed = False
         intActivityTimer = 0
         enmState = ELinkStates.Connecting
         SendCommand("%B", stcSelectedChannel.TNCPort)
         SendCommand("M N", stcSelectedChannel.TNCPort)
      Catch
         Logs.Exception("[PTCIIClient.Connect J] " & Err.Description)
      End Try
      Return True
   End Function ' Connect 

   Private Function ConnectTarget(ByVal Script As String) As String
      ' Extracts the target call from the connect script...

      Dim strTemp As String
      Dim intPt As Integer

      strTemp = Script.Trim.ToUpper
      intPt = strTemp.IndexOf("C ")
      If intPt <> -1 Then
         strTemp = strTemp.Substring(intPt + 1).Trim
      Else
         intPt = strTemp.IndexOf("CONNECT ")
         If intPt <> 0 Then
            strTemp = strTemp.Substring(intPt + 7).Trim
         Else
            Return ""
         End If
      End If
      Return strTemp.Split(CChar(" "))(0).Trim
   End Function ' ConnectTarget

   Public Sub DataToSend(ByVal sData As String) Implements IClient.DataToSend
      ' Adds data to the outbound queue...

      Dim objEncoder As New ASCIIEncoding
      DataToSend(GetBytes(sData))
   End Sub ' DataToSend (String) 

   Public Sub DataToSend(ByVal bytData() As Byte) Implements IClient.DataToSend
      ' Adds data to the outbound queue.

      intActivityTimer = 0
      Try
         Select Case stcSelectedChannel.TNCPort
            Case 31 ' Pactor
               ' Reset the confirmed data count...  
               SendCommand("%T", stcSelectedChannel.TNCPort)
               Poll()

               If bytData.Length > 0 Then
                  objHostPort.DataToSend(bytData, stcSelectedChannel.TNCPort)
                  objHostPort.Poll()
               End If
            Case Else ' Packet
               If bytData.Length > 0 Then
                  objHostPort.DataToSend(bytData, stcSelectedChannel.TNCPort)
                  objHostPort.Poll()
               End If
         End Select
      Catch
         Logs.Exception("[PTCIIClient.SendData] Port=" & stcSelectedChannel.TNCPort.ToString & " - " & Err.Description)
      End Try
   End Sub  ' DataToSend (Byte()) 

   Public Sub Disconnect() Implements IClient.Disconnect
      ' Invokes a channel disconnect...

      If stcConnectedCall.PendingDisconnect Or enmState = ELinkStates.Connecting Then
         ImmediateDisconnect()
         If Not IsNothing(objProtocol) Then
            objProtocol.LinkStateChange(EConnection.Disconnected)
            objProtocol = Nothing
            enmState = ELinkStates.Disconnected
         Else
            enmState = ELinkStates.LinkFailed
         End If
      Else
         stcConnectedCall.PendingDisconnect = True
         stcConnectedCall.StartDisconnect = Now
         SendCommand("D", stcSelectedChannel.TNCPort)
      End If
      queProgressDisplay.Enqueue(0)
   End Sub ' Disconnect 

   Private Function EndScript(ByVal strText As String) As Boolean
      ' Tests for any script bailouts...

      Dim strEndText() As String = {"DISCONNECTED", "TIMEOUT", "EXCEEDED", "FAILURE", "BUSY"}
      For intIndex As Integer = 0 To UBound(strEndText)
         If strText.ToUpper.IndexOf(strEndText(intIndex)) <> -1 Then Return True
      Next intIndex
      Return False
   End Function ' EndScript

   Private Function ImmediateDisconnect() As Boolean
      ' Function to send an immediate disconnect command to the PTC II in host mode...

      ' Returns True if sucessful, False otherwise
      Dim dttStart As Date = Now
      blnCommandReply = False
      strCommandReply = ""
      Try
         If stcSelectedChannel.ChannelType = EChannelModes.PactorTNC Then
            SendCommand("#DD", stcSelectedChannel.TNCPort)
         Else ' Two packet disconnects for packet mode
            SendCommand("D", stcSelectedChannel.TNCPort)
            Thread.Sleep(100)
            SendCommand("D", stcSelectedChannel.TNCPort)
         End If
      Catch
      End Try

      ' Wait for reply?
      While Now.Subtract(dttStart).TotalMilliseconds < 1200 And Not blnCommandReply
         If objHostPort IsNot Nothing Then objHostPort.Poll()
         Thread.Sleep(50)
      End While
      Return True
   End Function ' ImmediateDisconnect

   Private Function InitializeTheTNC() As Boolean
      '  Function to initialize the PTC II TNC...

      If blnPactorDialogResuming = False Then
         queChannelDisplay.Enqueue("G*** Initializing the " & stcSelectedChannel.TNCType & " TNC")
      End If

      ' Parse the connection script, if any, into the ConnectScript string array...
      If stcSelectedChannel.TNCScript <> "" Then
         ConnectScript = (stcSelectedChannel.TNCScript.Replace(vbLf, "")).Split(CChar(vbCr))
      End If

      If objHostPort.Startup Then
         If blnPactorDialogResuming = False Then
            queChannelDisplay.Enqueue("G*** TNC " & stcSelectedChannel.TNCType & _
               " on serial port " & stcSelectedChannel.TNCSerialPort & " initialized OK")
         End If
         blnHostMode = True
         If blnDoFECId Then
            blnDoFECId = False
            SendIdentification()
         End If
         Return True
      Else
         queChannelDisplay.Enqueue("R*** TNC " & stcSelectedChannel.TNCType & _
            " on serial port " & stcSelectedChannel.TNCSerialPort & " initialization failed")
         Return False
      End If
   End Function ' Initialize

   Public Sub New()
      blnChannelActive = True
      If stcSelectedChannel.ChannelType = EChannelModes.PacketTNC Then queStateDisplay.Enqueue("Packet")
      If stcSelectedChannel.ChannelType = EChannelModes.PactorTNC Then blnPactorDialogResume = Not stcSelectedChannel.EnableAutoforward
   End Sub ' New

   Public Property NormalDisconnect() As Boolean Implements IClient.NormalDisconnect
      Get
         Return blnNormalDisconnect
      End Get
      Set(ByVal value As Boolean)
         blnNormalDisconnect = value
      End Set
   End Property ' NormalDisconnect

   Private Sub OneSecondEvent()
      ' One second event for script timing, Pactor connect, timeouts.
      ' Called by ClientPTCII.Poll()...

      If Not blnWaitingForManualConnect Then intActivityTimer += 1
      If intActivityTimer > 60 * stcSelectedChannel.TNCTimeout Then
         queChannelDisplay.Enqueue("R*** " & stcSelectedChannel.TNCTimeout.ToString & " minute activity timeout at " & _
            Format(Date.UtcNow, "yyyy/MM/dd HH:mm UTC"))
         ImmediateDisconnect()

         Dim dttStartDisconnect As Date = Now
         While Now.Subtract(dttStartDisconnect).TotalMilliseconds < 2000
            Thread.Sleep(100)
            objHostPort.Poll()
         End While

         ' The following allows the Pactor manual user to retry a connect with a different PMBO/frequency
         If stcSelectedChannel.ChannelType = EChannelModes.PactorTNC And (Not blnAutomaticConnect) And _
         (Not blnNormalDisconnect) And (enmState <> ELinkStates.Initialized) Then
            enmState = ELinkStates.Initialized ' This allows bypassing the initialization 
            queRateDisplay.Enqueue("------")
            Return
         End If
         ' All other timeout attempts take this path
         If Not IsNothing(objProtocol) Then
            objProtocol.LinkStateChange(EConnection.Disconnected)
            objProtocol = Nothing
         End If
         enmState = ELinkStates.LinkFailed
         Return
      End If

      If intConnectScriptPtr <> -1 Then
         intScriptTimer += 1
         If intScriptTimer > stcSelectedChannel.TNCScriptTimeout Then
            intConnectScriptPtr = -1
            queChannelDisplay.Enqueue("R #Connect Script Timeout at " & _
               Format(Date.UtcNow, "yyyy/MM/dd HH:mm UTC") & " - disconnecting")
            ImmediateDisconnect()
            enmState = ELinkStates.LinkFailed
         End If
      ElseIf intConnectTimer > 0 Then
         intConnectTimer -= 1
         If intConnectTimer <= 0 Then
            intConnectTimer = 0

            ' Connect Timeout condition
            queChannelDisplay.Enqueue("R*** Connection timeout")
            blnStandby = False ' Preset standby flag false
            ImmediateDisconnect()

            If Not IsNothing(objProtocol) Then
               objProtocol.LinkStateChange(EConnection.Disconnected)
               objProtocol = Nothing
            End If
            enmState = ELinkStates.LinkFailed
            blnStartingChannel = True
            Return
         End If
      ElseIf stcConnectedCall.PendingDisconnect And Now.Subtract(stcConnectedCall.StartDisconnect).TotalSeconds > 10 Then
         ImmediateDisconnect()
         Thread.Sleep(500)
         If blnNormalDisconnect Then
            enmState = ELinkStates.Disconnected
         Else
            enmState = ELinkStates.LinkFailed
         End If
      End If

      If stcSelectedChannel.ChannelType = _
         EChannelModes.PactorTNC And objHostPort.blnISS And objProtocol IsNot Nothing Then
         ' Request bytes sent report...
         SendCommand("%T", stcSelectedChannel.TNCPort)
      ElseIf stcSelectedChannel.ChannelType = EChannelModes.PacketTNC Then
         SendCommand("L", stcSelectedChannel.TNCPort)
      End If
   End Sub ' OneSecondEvent

   Private Sub OnLinkActivity() Handles objHostPort.OnActivity
      intActivityTimer = 0
   End Sub ' OnLinkActivity

   Private Sub OnPTCControl(ByVal strData As String) Handles objHostPort.OnPTCControl
      ' Receives control command responses from the SCS host port...

        If strData = "" Then Return

        ' Process reply from L request for channel information.
        Dim strTokens() As String = strData.Split(" "c)
        If strTokens.Length = 6 Then
            ' Update the status display window (keyboard window)...
            Dim strReport As String
            strTokens(5) = strTokens(5).Substring(0, strTokens(5).Length - 1)
            If IsNumeric(strTokens(5)) Then
                Select Case strTokens(5)
                    Case "0" : strReport = "Packet - Disconnected"
                    Case "1" : strReport = "Packet - Linking"
                    Case "2" : strReport = "Packet - Frame Reject"
                    Case "3" : strReport = "Packet - Disconnect Request"
                    Case "4" : strReport = "Packet - Information Transfer"
                    Case "5" : strReport = "Packet - Reject Frame Sent"
                    Case "6" : strReport = "Packet - Waiting Acknowledgement"
                    Case "7" : strReport = "Packet - Device Busy"
                    Case "8" : strReport = "Packet - Remote Device Busy"
                    Case "9" : strReport = "Packet - Both Devices Busy"
                    Case "10" : strReport = "Packet - Waiting Acknowledgement and Device Busy"
                    Case "11" : strReport = "Packet - Waiting Acknowledgement and Remote Busy"
                    Case "12" : strReport = "Packet - Waiting Acknowledgement and Both Devices Busy"
                    Case "13" : strReport = "Packet - Reject Frame Send and Device Busy"
                    Case "14" : strReport = "Packet - Reject Frame Send and Remote Busy"
                    Case "15" : strReport = "Packet - Reject Frame Send and Both Devices Busy"
                End Select

                ' Include byte transfer counts if available...
                'queStateDisplay.Enqueue(strReport & "  " & ProgressBarStatus())

                ' Update the TNC frames window variable...
                If IsNumeric(strTokens(2)) Then objHostPort.intTNCFramesPending = CInt(strTokens(2))
                Return
            End If
        End If

      ' Process reply from a %T request for Pactor bytes sent...
      If stcSelectedChannel.ChannelType = EChannelModes.PactorTNC And enmState = ELinkStates.Connected Then
         If IsNumeric(strData) Then
            Dim intNewBytesSentCount As Integer = CInt(strData)
            If intNewBytesSentCount > 0 Then
               If intBytesSentCount > intNewBytesSentCount Then intBytesSentCount = intNewBytesSentCount
               UpdateProgressBar(intNewBytesSentCount - intBytesSentCount)
               If (intNewBytesSentCount - intBytesSentCount) > 0 Then
                  intActivityTimer = 0 ' Reset the inactivity counter if bytes flowing
                  intBytesSentCount = intNewBytesSentCount
                  objHostPort.intTNCBytesSent = intNewBytesSentCount
               End If
            End If
            Return
            End If

            ' See if this is a response to a L command to check link state.
        ElseIf stcSelectedChannel.ChannelType = EChannelModes.PacketTNC Then
            ' -- Response to L command --
            '  v0 v1 v2 v3 v4 v5
            ' v0 = Number of link status messages not yet displayed
            ' v1 = Number of receive frames not yet displayed
            ' v2 = Number of send frames not yet transmitted
            ' v3 = Number of transmitted frames not yet acknowledged
            ' v4 = Number of tries on current operation
            ' v5 = Link state

            'Dim strTokens() As String = strData.Split(" "c)
            strTokens = strData.Split(" "c)
            If strTokens.Length = 6 Then
                ' Update the status display window (keyboard window)...
                Dim strReport As String
                strTokens(5) = strTokens(5).Substring(0, strTokens(5).Length - 1)
                If IsNumeric(strTokens(5)) Then
                    Select Case strTokens(5)
                        Case "0" : strReport = "Packet - Disconnected"
                        Case "1" : strReport = "Packet - Linking"
                        Case "2" : strReport = "Packet - Frame Reject"
                        Case "3" : strReport = "Packet - Disconnect Request"
                        Case "4" : strReport = "Packet - Information Transfer"
                        Case "5" : strReport = "Packet - Reject Frame Sent"
                        Case "6" : strReport = "Packet - Waiting Acknowledgement"
                        Case "7" : strReport = "Packet - Device Busy"
                        Case "8" : strReport = "Packet - Remote Device Busy"
                        Case "9" : strReport = "Packet - Both Devices Busy"
                        Case "10" : strReport = "Packet - Waiting Acknowledgement and Device Busy"
                        Case "11" : strReport = "Packet - Waiting Acknowledgement and Remote Busy"
                        Case "12" : strReport = "Packet - Waiting Acknowledgement and Both Devices Busy"
                        Case "13" : strReport = "Packet - Reject Frame Send and Device Busy"
                        Case "14" : strReport = "Packet - Reject Frame Send and Remote Busy"
                        Case "15" : strReport = "Packet - Reject Frame Send and Both Devices Busy"
                    End Select

                    ' Include byte transfer counts if available...
                    queStateDisplay.Enqueue(strReport & "  " & ProgressBarStatus())

                    ' Update the TNC frames window variable...
                    If IsNumeric(strTokens(2)) Then objHostPort.intTNCFramesPending = CInt(strTokens(2))
                    Return
                End If
            End If
      End If

      Dim intChannel As Integer
      Dim intPtr1 As Integer = strData.IndexOf("(")
      Dim intPtr2 As Integer = strData.IndexOf(")")
      If intPtr1 <> -1 And intPtr2 > intPtr1 Then
         Try
            intChannel = CInt(strData.Substring(intPtr1 + 1, intPtr2 - (intPtr1 + 1)))
         Catch
         End Try
      End If

      If strData.StartsWith("*** ") Then queChannelDisplay.Enqueue("P" & strData)
      If strData.IndexOf("*** Host Mode") <> -1 Then
         blnHostMode = True
      ElseIf strData.IndexOf("*** PTC Fault") <> -1 Or strData.IndexOf("*** Serial Port Fault") <> -1 Then
         enmState = ELinkStates.LinkFailed
      ElseIf strData.IndexOf("CONNECTED to") <> -1 Then
         strData = strData.Replace("(31)", "").Trim
         queChannelDisplay.Enqueue("P" & strData & "  @ " & TimestampEx())
         stcConnectedCall.Callsign = strData.Substring(12 + strData.IndexOf("CONNECTED to")).Trim
         intConnectTimer = 0 ' Reset the ConnectCtr

         If intChannel = 31 Then ' A Pactor connect
            enmState = ELinkStates.Connected
            intActivityTimer = 0
            intBytesSentCount = 0
            objHostPort.intTNCBytesSent = 0
            objHostPort.intTNCBytesPosted = 0
            objProtocol = New ProtocolInitial(Me, stcSelectedChannel)
         ElseIf intChannel <> 0 Then ' A packet connect connection ID will be in intChannel
            Try
               Select Case stcSelectedChannel.TNCType
                  Case "PTC-II", "PTC-IIpro"
                     stcConnectedCall.Port = CInt(stcConnectedCall.Callsign.Substring(0, 1))
                     stcConnectedCall.Callsign = stcConnectedCall.Callsign.Substring(2).Trim
                  Case "PTC-IIe", "PTC-IIex", "PTC-IIusb"
                     stcConnectedCall.Port = 1
               End Select
            Catch
               Logs.Exception("[PTCIIClient.OnPTCControl] " & Err.Description)
               Return
            End Try
            enmState = ELinkStates.Connected
            objProtocol = New ProtocolInitial(Me, stcSelectedChannel)
         Else
            Return
         End If

      ElseIf strData.IndexOf("DISCONNECTED") <> -1 Or strData.IndexOf("LINK FAIL") <> -1 Then
         strData = strData.Replace("(31)", "").Trim
         If Not blnDisconnectProcessed Then
            blnDisconnectProcessed = True
            queChannelDisplay.Enqueue("P" & strData & "  @ " & TimestampEx())
            If (Not IsNothing(objProtocol)) And (stcSelectedChannel.ChannelType = EChannelModes.PacketTNC) Then
               ' A connection was established which created objProtocol...
               objProtocol.LinkStateChange(EConnection.Disconnected)
               objProtocol = Nothing
               If strData.IndexOf("LINK FAIL") <> -1 Then
                  enmState = ELinkStates.LinkFailed
               Else
                  enmState = ELinkStates.Disconnected
               End If
            ElseIf (Not IsNothing(objProtocol)) And (stcSelectedChannel.ChannelType = EChannelModes.PactorTNC) And _
               (blnAutomaticConnect Or blnNormalDisconnect) Then
               ' A connection was established which created objProtocol
               'SendIdentification()
               blnDoFECId = True
               objProtocol.LinkStateChange(EConnection.Disconnected)
               objProtocol = Nothing
               If strData.IndexOf("LINK FAIL") <> -1 Then
                  enmState = ELinkStates.LinkFailed
               Else
                  enmState = ELinkStates.Disconnected
               End If
            ElseIf (stcSelectedChannel.ChannelType = EChannelModes.PactorTNC) And (Not blnAutomaticConnect) _
               And (Not blnNormalDisconnect) And (enmState <> ELinkStates.Initialized) Then
               ' Not automatic so allow selecting another RMS and or frequency...
               enmState = ELinkStates.Initialized ' This allows bypassing the Initialization
               'SendIdentification()
               blnDoFECId = True
               If objProtocol IsNot Nothing Then
                  objProtocol.LinkStateChange(EConnection.Disconnected)
                  objProtocol = Nothing
               End If
               queRateDisplay.Enqueue("------")
               enmState = ELinkStates.Disconnected
               Return
            Else
               enmState = ELinkStates.LinkFailed
            End If
         Else
            Return ' Disconnect already processed
         End If

         If (stcSelectedChannel.ChannelType = EChannelModes.PactorTNC) And (Not blnAutomaticConnect) _
            And (enmState <> ELinkStates.Initialized) And (blnPactorDialogResume) Then
            ' Not automatic so allow selecting another RMS Frequency...
            queRateDisplay.Enqueue("------")
         End If

      ElseIf strData.IndexOf("Current port settings") <> -1 Then
         If stcSelectedChannel.ChannelType = EChannelModes.PacketTNC Then
            If strData.IndexOf("9600") <> -1 Then
               queRateDisplay.Enqueue("9600 Baud")
            Else
               queRateDisplay.Enqueue("1200 Baud")
            End If
         End If
      Else
         strCommandReply = strData
         blnCommandReply = True
      End If

   End Sub ' OnPTCControl

   Private Sub OnPTCData(ByVal bytData() As Byte) Handles objHostPort.OnPTCData
      ' Receives channel data from the SCS host port...

      Dim bytPureData(bytData.Length - 4) As Byte
      Array.Copy(bytData, 3, bytPureData, 0, bytPureData.Length)
      intActivityTimer = 0 ' Reset the Inbound counter with each data frame
      If intConnectScriptPtr <> -1 Then ' Still sequencing the connecction script
         If Not SequenceScript(GetString(bytPureData), stcConnectedCall.Callsign) Then Return
      End If
      If objProtocol IsNot Nothing Then objProtocol.ChannelInput(bytPureData)
   End Sub ' OnPTCData

   Private Sub OnPTCError(ByVal strText As String) Handles objHostPort.OnPTCError
      queChannelDisplay.Enqueue("P*** " & strText)
      Logs.Exception("[PTCIIClient.OnPTCError] " & strText)
   End Sub ' OnPTCError

   Private Sub OnPTCStatusReport(ByVal bytStatus() As Byte) Handles objHostPort.OnPTCStatusReport
      Static blnConnected As Boolean

      If stcSelectedChannel.ChannelType = EChannelModes.PactorTNC Then
         If bytStatus.Length = 4 Or bytStatus.Length = 7 Then
            ' Decode the basic status byte...
            bytLink = bytStatus(3) And CByte(&H7)
            bytMode = bytStatus(3) And CByte(&H70)
            Select Case bytMode
               Case 0
                  strStatus = "Standby "
                  blnStandby = True
                  If dlgPactorConnect IsNot Nothing Then dlgPactorConnect.ChannelBusy = False
               Case &H20 : strStatus = "Pactor ARQ "
                  blnStandby = False
               Case &H40
                  strStatus = "Pactor FEC "
                  blnStandby = False
               Case &H70
                  blnStandby = False
                  strStatus = "Channel Busy "
                  If dlgPactorConnect IsNot Nothing Then dlgPactorConnect.ChannelBusy = True
               Case Else : strStatus = "Packet "
            End Select
            bytDirection = bytStatus(3) And CByte(&H8)
            If bytDirection > 0 Then objHostPort.blnISS = True Else objHostPort.blnISS = False
            If bytMode = &H20 Then
               If bytDirection > 0 Then strStatus &= "Sending " Else strStatus &= "Receiving "
               Select Case bytLink
                  Case 0, 1 : strStatus &= "Repeating "
                  Case 2 : strStatus &= "Traffic "
                  Case 3 : strStatus &= "Idle "
                  Case 4 : strStatus &= "Over "
                  Case 5 : strStatus &= "Phasing "
                  Case 6 : strStatus &= "Linking "
                  Case 7 : strStatus &= "Calling "
               End Select
            End If
         End If
         If bytStatus.Length = 7 Then
            ' Decode the extended status report...
            If bytStatus(4) = 0 Then
               If blnConnected Then
                  blnConnected = False
               End If
               objHostPort.blnISS = False
               If stcConnectedCall.PendingDisconnect Then
                  If Not IsNothing(objProtocol) Then
                     objProtocol.LinkStateChange(EConnection.Disconnected)
                     objProtocol = Nothing
                     enmState = ELinkStates.Disconnected
                  Else
                     enmState = ELinkStates.LinkFailed
                  End If
               End If
            Else
               Select Case bytStatus(4)
                  Case 1
                     Select Case bytStatus(5)
                        Case 0 : queRateDisplay.Enqueue("P" & bytStatus(4).ToString & " - 100")
                        Case 1 : queRateDisplay.Enqueue("P" & bytStatus(4).ToString & " - 200")
                     End Select
                  Case 2
                     Select Case bytStatus(5)
                        Case 0 : queRateDisplay.Enqueue("P" & bytStatus(4).ToString & " - 100")
                        Case 1 : queRateDisplay.Enqueue("P" & bytStatus(4).ToString & " - 200")
                        Case 2 : queRateDisplay.Enqueue("P" & bytStatus(4).ToString & " - 400")
                        Case 3 : queRateDisplay.Enqueue("P" & bytStatus(4).ToString & " - 800")
                        Case Else : queRateDisplay.Enqueue("P" & bytStatus(4).ToString & " - 800")
                     End Select
                  Case 3
                     Select Case bytStatus(5)
                        Case 0 : queRateDisplay.Enqueue("P" & bytStatus(4).ToString & " - 200")
                        Case 1 : queRateDisplay.Enqueue("P" & bytStatus(4).ToString & " - 800")
                        Case 2 : queRateDisplay.Enqueue("P" & bytStatus(4).ToString & " - 1400")
                        Case 3 : queRateDisplay.Enqueue("P" & bytStatus(4).ToString & " - 2800")
                        Case 4 : queRateDisplay.Enqueue("P" & bytStatus(4).ToString & " - 3200")
                        Case 5 : queRateDisplay.Enqueue("P" & bytStatus(4).ToString & " - 3600")
                        Case Else : queRateDisplay.Enqueue("P" & bytStatus(4).ToString & " - 3600")
                     End Select
               End Select
               If enmState <> ELinkStates.Connected And bytStatus(4) <> 0 Then
                  enmState = ELinkStates.Connected
                  intActivityTimer = 0
                  objProtocol = New ProtocolInitial(Me, stcSelectedChannel)
               End If
            End If
            If bytStatus(6) <> &H80 Then
               Dim intSign As Integer

               If bytStatus(6) >= &H80 Then intSign = -1 Else intSign = 1
               Dim intOffset As Integer = CInt(bytStatus(6) And &H7F)
               If intSign = -1 Then intOffset = intOffset Or &HFFFFFF80
               strStatus &= "Offset: " & intOffset.ToString & " Hz"
            End If
         End If

         queStateDisplay.Enqueue(strStatus & "  " & ProgressBarStatus())
      End If
   End Sub ' OnPTCStatusReport

   Public Function OpenSerialPort() As Boolean
      ' Instantiate a new SCSHostPort...
      Try
         If Not IsNothing(objHostPort) Then
            objHostPort.Close()
            objHostPort = Nothing
         End If
         objHostPort = New SCSHostPort()

         ' Open the host port's serial port...
         If Not objHostPort.Open() Then
            'If blnPactorDialogResuming = False Then
            queChannelDisplay.Enqueue("R*** TNC " & stcSelectedChannel.TNCType & _
               " initialization failed on serial port " & stcSelectedChannel.TNCSerialPort)
            queChannelDisplay.Enqueue("R*** Serial port may be in use by another application")
            'End If
            objHostPort = Nothing
            Return False
         Else
            Return True
         End If
      Catch
         Logs.Exception("[Client.OpenSerialPort] " & Err.Description)
         objHostPort = Nothing
         Return False
      End Try
   End Function ' OpenSerialPort

   Private Sub Poll() Implements IClient.Poll
      ' Called from Main at 100 millisecond intervals...

      Static intCalls As Integer
      intCalls += 1
      If intCalls >= 10 Then
         intCalls = 0
      End If

      If objHostPort IsNot Nothing Then
         If dlgPactorConnect IsNot Nothing Then
            If intCalls = 0 Then OneSecondEvent()
         ElseIf intCalls = 0 Then
            ' Request status here...
            objHostPort.PostQuery()
         End If
         objHostPort.Poll()
      End If
   End Sub ' Poll 

   Private Function RunScript(ByRef strVia As String, ByRef strTarget As String) As Boolean
      ' Starts the connection script. Returns True if OK False if script or processing error...

      Try
         RunScript = True
         intScriptTimer = 0 '  initialize the script timer
         strVia = ""
         If Nothing Is ConnectScript Then
            intConnectScriptPtr = -1 ' This sets the script pointer to signal inactive
            Return True ' No script. Do not update strTarget.
         Else
            Dim intPt As Integer
            Dim strTemp As String
            Dim strTok As String
            strTemp = " " & ConnectScript(0).ToUpper.Trim

            ' This strips off any leading V or Via (case insensitive) and skips over any syntax "Connect via"
            intPt = strTemp.IndexOf(" V ")
            If intPt <> -1 Then
               strVia = " " & strTemp.Substring(intPt + 2).Trim.Replace(",", " ") '' For PTC II replace "," via delimiters with space
               strVia = strVia.Replace("  ", " ") ' remove any double spaces
            Else
               intPt = strTemp.IndexOf(" VIA ")
               If intPt <> -1 Then
                  strVia = " " & strTemp.Substring(intPt + 4).Trim.Replace(",", " ") '' For PTC II replace "," via delimiters with space
                  strVia = strVia.Replace("  ", " ") ' remove any double spaces
               End If
            End If
            If UBound(ConnectScript) = 0 Then
               queChannelDisplay.Enqueue("R*** Requesting connection to " & _
                  stcSelectedChannel.RemoteCallsign & " via " & strVia & " at " & Timestamp())

               ' Simple via connect, just a single line (not a true script)
               intConnectScriptPtr = -1 '   Set script pointer to inactive, strVia is updated, strTarget is unchanged
               Return True
            Else
               ' True script processing here (indicated by at least two Connection script lines)
               intConnectScriptPtr = 0 ' Initialize ptr to first script line (signals the script is active)
               intActivityTimer = 0
               strTok = ConnectTarget(ConnectScript(0))
               If strTok <> "" Then
                  strTarget = strTok ' sTarget is updated 
                  queChannelDisplay.Enqueue("G #Begin Connection Script")
                  queChannelDisplay.Enqueue("G     #Script(" & CStr(intConnectScriptPtr + 1) & "): " & _
                     ConnectScript(intConnectScriptPtr))
               Else
                  RunScript = False
               End If
            End If
         End If
      Catch
         Return False
      End Try
   End Function ' RunScript

   Private Sub SendCommand(ByVal bytCommand() As Byte, ByVal intChannel As Integer)
      ' Send a command to the PTC via the control channel...

      If objHostPort IsNot Nothing AndAlso objHostPort.HostState = SCSHostPort.HostModeState.HostMode Then
         blnCommandReply = False
         Try
            objHostPort.SendHostCommandPacket(bytCommand, CByte(intChannel))
            objHostPort.Poll()
            Dim dttStart As Date = Now
         Catch
            Logs.Exception("[PTCHostMode.SendCommand(Byte)] " & Err.Description)
         End Try
      End If
   End Sub  ' SendCommand (Byte)

   Private Sub SendCommand(ByVal strCommand As String, ByVal intChannel As Integer)
      ' Send a command to the PTC via the control channel...

      If objHostPort IsNot Nothing AndAlso objHostPort.HostState = SCSHostPort.HostModeState.HostMode Then
         blnCommandReply = False
         Try
            objHostPort.SendHostCommandPacket(strCommand, CByte(intChannel))
            objHostPort.Poll()
            Dim dttStart As Date = Now
         Catch
            Logs.Exception("[PTCHostMode.SendCommand(String)] " & _
               Err.Description & " Command:" & intChannel.ToString & "/" & strCommand)
         End Try
      End If
   End Sub  ' SendCommand (String)

   Public Sub SendRadioCommand(ByVal bytCommand() As Byte) Implements IClient.SendRadioCommand
      ' Function to send radio command via PTC II...
      SendCommand(bytCommand, 31)
   End Sub ' SendRadioCommand (Byte)

   Public Sub SendRadioCommand(ByVal strCommand As String) Implements IClient.SendRadioCommand
      ' Function to send radio command via PTC II...
      SendCommand(strCommand, 31)
   End Sub ' SendRadioCommand (String)

   Private Sub SendIdentification()
      stcConnectedCall.PendingDisconnect = False

      If blnSendingID Or (stcSelectedChannel.ChannelType <> EChannelModes.PactorTNC) Or _
      (Not stcSelectedChannel.PactorId) Or blnNoIdentification Or blnIDSending Then Return ' Prevents sending ID twice
      blnSendingID = True

      If objHostPort IsNot Nothing AndAlso objHostPort.HostState = SCSHostPort.HostModeState.HostMode Then
         ' Sends station callsign in Pactor I FEC...
         SendCommand("#CL", 31)     ' Clear the transmit buffer
         SendCommand("#U *1", 31)   ' Repeat 1 time
         SendCommand("#U 1", 31)    ' Use FSK 100 baud mode
         Thread.Sleep(1000)
         DataToSend(" DE " & SiteCallsign & " ")

         ' Wait five seconds...
         Dim intTicks As Integer
         Do
            intTicks += 1
            If intTicks > 30 Then Exit Do
            objHostPort.Poll()
            Thread.Sleep(100)
         Loop

         ' End FEC transmission...
         SendCommand("#DD", 31)
         intTicks = 0
         Do
            intTicks += 1
            If intTicks > 10 Then Exit Do
            objHostPort.Poll()
            Thread.Sleep(100)
         Loop
      End If

      blnSendingID = False
   End Sub ' SendIdentification

   Private Function SequenceScript(ByVal Text As String, ByVal From As String) As Boolean
      ' Sequences the connect script. Returns True if scripting is completed, False otherwise...

      Dim strDataToSend As String
      Dim blnTextFound As Boolean

      Select Case intConnectScriptPtr
         Case -1  ' No scripting
            If Text.StartsWith("***") Then
               queChannelDisplay.Enqueue("P" & Text)
            Else
               queChannelDisplay.Enqueue("X" & Text)
            End If
            enmState = ELinkStates.Connected
            objProtocol = New ProtocolInitial(Me, stcSelectedChannel)
            Return True
         Case Else  '  Script Ptr should always be even
            queChannelDisplay.Enqueue("X" & Text)
            If EndScript(Text) Then ' Check for aborted script
               queChannelDisplay.Enqueue("G #Script stopped: " & Text)
               intConnectScriptPtr = -1 '   Terminate the scripting
               ImmediateDisconnect()
               Return False
            ElseIf ConnectScript.Length > intConnectScriptPtr + 1 Then
               blnTextFound = InStr(Text.ToUpper, ConnectScript(intConnectScriptPtr + 1)) <> 0
               If blnTextFound And intConnectScriptPtr + 2 < ConnectScript.Length Then
                  intScriptTimer = 0 ' Reset the script timer
                  queChannelDisplay.Enqueue("G     #Script(" & CStr(intConnectScriptPtr + 2) & "): " & _
                     ConnectScript(intConnectScriptPtr + 1))
                  intConnectScriptPtr += 2
                  strDataToSend = ConnectScript(intConnectScriptPtr)
                  queChannelDisplay.Enqueue("G     #Script(" & CStr(intConnectScriptPtr + 1) & "): " & _
                     strDataToSend)
               ElseIf blnTextFound Then
                  intScriptTimer = 0
                  queChannelDisplay.Enqueue("G     #Script(" & CStr(intConnectScriptPtr + 2) & "): " & _
                     ConnectScript(intConnectScriptPtr + 1))
                  queChannelDisplay.Enqueue("G #End Script")
                  enmState = ELinkStates.Connected
                  intConnectScriptPtr = -1 '   Terminate the scripting
                  objProtocol = New ProtocolInitial(Me, stcSelectedChannel)
                  SequenceScript = True
               End If
            Else ' Must be an odd number of scrip lines 
               queChannelDisplay.Enqueue("G #Script terminated (end of script file): " & Text)
               enmState = ELinkStates.Connected
               intConnectScriptPtr = -1 '   Terminate the scripting
               objProtocol = New ProtocolInitial(Me, stcSelectedChannel)
               SequenceScript = True
            End If
      End Select
      If strDataToSend <> "" Then
         Dim bytData() As Byte
         Dim objEncoder As New ASCIIEncoding
         bytData = GetBytes(strDataToSend & vbCr)

         ' Send the data here...
         DataToSend(bytData)
      End If
   End Function ' SequenceScript

   Public ReadOnly Property State() As ELinkStates Implements IClient.State
      Get
         Return enmState
      End Get
   End Property ' State 
End Class

Public Class SCSHostPort

   Public Enum HostModeState
      HostModeClosed
      PTCStart
      PTCInitializing
      PTCFault
      HostMode
      SerialPortFault
   End Enum

   ' Function declarations...
    'Declare Function UPDCRC Lib "VBSUPPORT.DLL" (ByVal value As Byte, ByVal CRC As Integer) As Integer

   ' Events...
   Public Event OnPTCError(ByVal strData As String)
   Public Event OnPTCStatusReport(ByVal bytStatus() As Byte)
   Public Event OnPTCControl(ByVal strData As String)
   Public Event OnPTCData(ByVal bytData() As Byte)
   Public Event OnPTCRadio(ByVal bytData() As Byte)
   Public Event OnActivity()

   ' Queues...
   Private quePortInput As Queue = Queue.Synchronized(New Queue) ' Holds raw byte received from serial port
   Private queDataOutbound As New Queue      ' Holds complete data host frames queued for the serial port
   Private queCommandOutbound As New Queue   ' Holds complete command host frames queued for the serial port

   ' Structures and enumerations...
   Private enmHostState As HostModeState     ' Holds the current host port state     

   ' Byte arrays...
   Private bytSOH() As Byte = {&H1} ' Used in attempt to recover the TNC
   Private bytExitCRCExtendedHostMode() As Byte = _
      {&HAA, &HAA, &H1F, &HC1, &H5, &H4A, &H48, &H4F, &H53, &H54, &H30, &H54, &HFA}

   Private bytRepeatRequest() As Byte = {&HAA, &HAA, &HAA, &H55}

   ' Strings and string builders
   Private sbdResponse As New StringBuilder

   ' Integers
   Public intTNCFramesPending As Integer
   Public intTNCBytesSent As Integer
   Public intTNCBytesPosted As Integer

   ' Booleans...
   Public blnISS As Boolean
   Private blnAcknowledged As Boolean  ' Set when a frame from the TNC is successfully decoded
   Private blnCmdSeen As Boolean       ' Set when a "cmd:" is received from the TNC (while not in host mode)
   Private blnAsteriskSeen As Boolean   ' Set when a "*" is received from the TNC (while not in host mode) indicating TNC emulation mode 2
   Private blnPacSeen As Boolean       ' Set when a "pac" is received from the TNC (while not in host mode)
   Private blnHostSync As Boolean      ' Set when "INVALID" is received from the TNC (while not in host mode)
   Private blnRepeatRequest As Boolean ' Set when a repeat request frame is received from the TNC
   Private blnClose As Boolean         ' Set when host mode is ended

   ' Objects and classes...
   Private WithEvents objSerial As SerialPort ' Serial port to the TNC

   Public Sub Abort()
      SendHostCommandPacket("%C", 31)
      queDataOutbound.Clear()
   End Sub ' Abort

   Private Sub AddCRC(ByRef bytPendingFrame() As Byte)
      ' Calculates and sets the CRC values into the last two bytes of the
      ' bytPendingFrame...
      Try
         Dim intCRC As Int32 = &HFFFF
         For intIndex As Integer = 2 To bytPendingFrame.Length - 3
                intCRC = Crc.UpdCrc(bytPendingFrame(intIndex), intCRC)
         Next
         intCRC = Not intCRC
         bytPendingFrame(bytPendingFrame.Length - 2) = CByte(intCRC And &HFF)
         bytPendingFrame(bytPendingFrame.Length - 1) = CByte((intCRC And &HFF00) \ 256)
      Catch
         Logs.Exception("[SCSHostPort.AddCRC] " & Err.Description)
      End Try
   End Sub ' AddCRC

   Private Sub AddStuffingBytes(ByRef bytPendingFrame() As Byte)
      ' Begin byte stuffing at location 2 (skip 170, 170 header)
      ' This insures two sequential bytes of 170 identifies Start of header

      Dim bytNewFrame(1000) As Byte
      Dim intPosition As Integer = 2
      Dim blnAAFound As Boolean
      Dim intIndex As Integer

      For intIndex = 2 To bytPendingFrame.Length - 1
         If bytPendingFrame(intIndex) <> &HAA Then ' No change use exisiting data...
            bytNewFrame(intPosition) = bytPendingFrame(intIndex)
            intPosition += 1
         Else ' Add a 0 byte stuff after the &HAA to insure never two adjacent &HAA bytes... 
            blnAAFound = True
            bytNewFrame(intPosition) = bytPendingFrame(intIndex)
            bytNewFrame(intPosition + 1) = 0
            intPosition += 2
         End If
      Next

      If blnAAFound = False Then
         Return
      Else
         ReDim bytPendingFrame(intPosition - 1)
         bytNewFrame(0) = &HAA
         bytNewFrame(1) = &HAA
         Array.Copy(bytNewFrame, bytPendingFrame, intPosition)
      End If
   End Sub ' AddStuffingBytes

   Private Function CheckCRC(ByRef bytFrame() As Byte, ByVal intUpperbound As Integer) As Boolean
      ' Checks the CRC on a received host mode data frame...

      Dim intCRC As Integer = &HFFFF
      For intIndex As Integer = 2 To intUpperbound - 2
            intCRC = Crc.UpdCrc(bytFrame(intIndex), intCRC)
      Next
      intCRC = Not intCRC
      If bytFrame(intUpperbound - 1) <> CByte(intCRC And &HFF) Then Return False
      If bytFrame(intUpperbound) <> CByte((intCRC And &HFF00) \ 256) Then Return False
      Return True
   End Function ' CheckCRC

   Public Sub Close()
      If Not blnClose Then
         If enmHostState <> HostModeState.HostModeClosed Then
            enmHostState = HostModeState.HostModeClosed
            queDataOutbound.Clear()
            queCommandOutbound.Clear()
            ExitHostMode()
         End If
         blnClose = True
         Try
            If objSerial IsNot Nothing Then
               If objSerial.IsOpen Then objSerial.Write("QUIT" & vbCr)
               Thread.Sleep(200)

               ' Release the serial port...
               objSerial.DiscardInBuffer()
               objSerial.DiscardOutBuffer()
               If objSerial.IsOpen Then
                  objSerial.Close()
                  Thread.Sleep(200)
               End If
               'objSerial.Dispose()
               objSerial = Nothing
            End If
         Catch
            Logs.Exception("[SCSHostPort.Close] " & Err.Description)
         End Try
      End If
   End Sub ' Close

   Public ReadOnly Property HostState() As HostModeState
      ' Returns the current state of the program and controller...
      Get
         Return enmHostState
      End Get
   End Property ' HostState

   Public ReadOnly Property OutboundPending() As Boolean
      Get
         Return queDataOutbound.Count > 0
      End Get
   End Property ' OutboundPending

   Public Sub DataToSend(ByVal bytDataToSend() As Byte, ByVal intChannel As Integer)
      ' Accepts data to be sent to the indicated channel. If the data is longer than
      ' 128 bytes then is is broken into 128 byte packets before posting to the outbound
      ' data queue. The channel number (intChannel) may be in the range 1 to 31 (&H1 to 
      ' &H1F). Pactor is always channel 31 (&H1F)...

      If bytDataToSend.Length < 1 Then Return ' Don't send a null packet
      If bytDataToSend.Length <= 128 Then
         PostDataPacket(bytDataToSend, intChannel)
      Else
         Dim intNumberOfFullPackets As Integer = bytDataToSend.Length \ 128
         Dim intRemainderPacket As Integer = bytDataToSend.Length Mod 128

         Dim intIndex As Integer
         For intIndex = 0 To intNumberOfFullPackets - 1
            Dim bytBuffer(127) As Byte
            Array.Copy(bytDataToSend, intIndex * 128, bytBuffer, 0, 128)
            PostDataPacket(bytBuffer, intChannel)
         Next

         If intRemainderPacket <> 0 Then
            Dim bytRemainder(intRemainderPacket - 1) As Byte
            Array.Copy(bytDataToSend, intNumberOfFullPackets * 128, bytRemainder, 0, intRemainderPacket)
            PostDataPacket(bytRemainder, intChannel)
         End If
      End If
   End Sub ' SendData 

   Public Sub ExitHostMode()
      enmHostState = HostModeState.HostModeClosed
      queDataOutbound.Clear()
        queCommandOutbound.Clear()
        Dim bytExitHostMode() As Byte = {&HAA, &HAA, &H1F, &H1, &H5, &H4A, &H48, &H4F, &H53, &H54, &H30, &H0, &H0}
      If objSerial IsNot Nothing Then
         queCommandOutbound.Enqueue(bytExitHostMode)
         SendNextFrame()
         Thread.Sleep(200)
      End If
      Thread.Sleep(2000)
   End Sub

   Private Function IsTNCCommandResponse(Optional ByVal chrCommand As Char = Chr(&HD)) As Boolean
      ' Returns true if the TNC responses with either "cmd:" or "PAC" or "*" following a
      ' CR (default) or other specified command...

      blnCmdSeen = False
      blnPacSeen = False
      blnAsteriskSeen = False ' used to detect case where TNC is in Emulation mode TNC 2
      blnHostSync = False
      sbdResponse.Length = 0
      Try
         objSerial.Write(chrCommand)
      Catch
      End Try
      Dim dttTimer As Date = Now.AddMilliseconds(2000)
      Do
         If (blnCmdSeen Or blnPacSeen Or blnAsteriskSeen) Then Return True
         If dttTimer < Now Then Return False
         Thread.Sleep(100)
         Poll()
         If blnClose Or blnProgramClosing Then Return False
      Loop
   End Function ' IsTNCCommandResponse

   Private Sub NewState(ByVal emnNewHostState As HostModeState)
      ' Called for any PTC controller state change...

      If emnNewHostState <> enmHostState Then
         enmHostState = emnNewHostState
         Select Case enmHostState
            Case HostModeState.PTCStart
               'RaiseEvent OnPTCControl("*** PTC Standby")
            Case HostModeState.PTCInitializing
               'RaiseEvent OnPTCControl("*** PTC Initializing")
            Case HostModeState.HostMode
               'RaiseEvent OnPTCControl("*** Host Mode")
            Case HostModeState.PTCFault
               RaiseEvent OnPTCControl("*** PTC Fault")
            Case HostModeState.SerialPortFault
               RaiseEvent OnPTCControl("*** Serial Port Fault")
            Case HostModeState.HostModeClosed
         End Select
      End If
   End Sub ' NewState

   Private Sub OnDataReceived(ByVal s As Object, ByVal e As SerialDataReceivedEventArgs) Handles objSerial.DataReceived
      ' Reads all pending bytes in the serial port and places them byte arrays on
      ' the serial port input queue...

      Dim intBytesToRead As Integer
      Try
         intBytesToRead = objSerial.BytesToRead
      Catch
      End Try

      If intBytesToRead > 0 Then
         Dim intBytesRead As Integer
         Dim bytInputBuffer(intBytesToRead - 1) As Byte

         intBytesRead = objSerial.Read(bytInputBuffer, 0, intBytesToRead)
         If intBytesRead <> intBytesToRead Then
            Logs.Exception("[SCSHostPort.DataReceivedEvent] Bytes read does not match bytes to read")
         End If
            ProcessDataReceived(bytInputBuffer)
            ' Try to send another packet immediately.
            If CanAcceptDataPacket() Then
                PollOutgoing()
            End If
        End If
    End Sub ' OnDataReceived 

    Public Function CanAcceptDataPacket() As Boolean
        Dim intMaxPendingPackets As Integer
        If stcSelectedChannel.TNCType = "PTC DR-7800" Then
            intMaxPendingPackets = 20
        Else
            intMaxPendingPackets = 10
        End If
        If blnAcknowledged And intTNCFramesPending < intMaxPendingPackets Then
            Return True
        End If
        Return False
    End Function

   Public Function Open() As Boolean
      ' Opens the serial port and calls Setup() to configure the TNC...

      Try
         objSerial = New SerialPort
         AddHandler objSerial.DataReceived, AddressOf OnDataReceived
         objSerial.PortName = stcSelectedChannel.TNCSerialPort
         ' objSerial.WriteTimeout = 1000
         objSerial.ReceivedBytesThreshold = 1
         objSerial.BaudRate = CInt(CInt(stcSelectedChannel.TNCBaudRate))
         objSerial.DataBits = 8
         objSerial.StopBits = StopBits.One
         objSerial.Parity = Parity.None
         objSerial.Handshake = Handshake.None ' Handshake.RequestToSend
         objSerial.RtsEnable = True
         objSerial.DtrEnable = True
         objSerial.DiscardNull = False
         objSerial.Open()
         objSerial.DiscardInBuffer()
         objSerial.DiscardOutBuffer()
         If Not objSerial.IsOpen Then
            NewState(HostModeState.SerialPortFault)
            queChannelDisplay.Enqueue("R*** " & stcSelectedChannel.TNCSerialPort & " failed to open")
            Return False
         End If
         Return True
      Catch
         Return False
      End Try
   End Function ' Open

   Public Sub Poll()
      If blnClose = False Then
         If enmHostState = HostModeState.HostMode Then
            PollOutgoing()
         End If
      End If
   End Sub ' Poll

   Private Sub PollOutgoing()
      Static dttReplyTimer As Date = Now
      Static intPendingPoll As Integer

      '
      ' Send in the "L" command every 4th time to update the number of unsent packets in the TNC.
      '
      intPendingPoll = (intPendingPoll + 1) Mod 4
      If intPendingPoll = 0 Then         '
         SendHostCommandPacket("L", CByte(stcSelectedChannel.TNCPort))
         Return
      End If

      If blnRepeatRequest Then
         ' Repeat the last frame if requested by the TNC...
         blnRepeatRequest = False
         SendNextFrame(True)
      ElseIf blnAcknowledged = False Then
         ' Repeat the last frame if no acknowledgement received within one second...
         If dttReplyTimer < Now Then
            dttReplyTimer = Now.AddMilliseconds(1000)
            SendNextFrame(True)
         End If
      Else
         ' Send the next frame in the queue if any are pending else send a 
         ' query command...
         dttReplyTimer = Now.AddMilliseconds(1000)
         If queDataOutbound.Count > 0 Or queCommandOutbound.Count > 0 Then
            SendNextFrame()
         Else
            PostQuery()
         End If
      End If
   End Sub ' PollOutgoing

   Private Sub PostDataPacket(ByVal bytData() As Byte, ByVal intChannel As Integer)
      ' Posts an outbound data packet to the outbound queue. The packet is
      ' formatted into host mode null terminated frame...

      If enmHostState = HostModeState.HostMode Then
         Dim bytFrame(bytData.Length + 6) As Byte
         bytFrame(0) = &HAA
         bytFrame(1) = &HAA
         bytFrame(2) = CByte(intChannel)
         bytFrame(3) = 0
         bytFrame(4) = CByte(bytData.Length - 1)
         For intIndex As Integer = 0 To bytFrame(4)
            bytFrame(intIndex + 5) = bytData(intIndex)
         Next
         queDataOutbound.Enqueue(bytFrame)
      Else
         Logs.Exception("[SCSHostPort.SendDataPacket] Not in host mode! State=" & enmHostState.ToString)
      End If
   End Sub ' SendDataPacket 

   Private Function PostPactorInboundNullTerminatedData(ByRef bytInboundHostModePacket() As Byte) As Boolean
      ' Receives a null terminated byte array and posts the data (with the
      ' host mode wrapper removed) to the Pactor control TCP/IP connection...

      Dim bytDataIn(300) As Byte
      Dim intIndex As Integer
      For intIndex = 0 To 300
         If bytInboundHostModePacket(intIndex + 2) = 0 Then Exit For
         bytDataIn(intIndex) = bytInboundHostModePacket(intIndex + 2)
      Next
      ReDim Preserve bytDataIn(intIndex - 1)
      Try
         RaiseEvent OnPTCControl(GetString(bytDataIn) & vbCr)
      Catch
      End Try
      blnAcknowledged = True
   End Function ' PostPactorInboundNullTerminatedData

   Public Sub PostQuery()
      Static dttTimer As Date = Now.AddMilliseconds(1000)
      If dttTimer < Now Then
         dttTimer = Now.AddMilliseconds(1000)
         Dim bytG3Query() As Byte = {&HAA, &HAA, &HFE, &H1, &H1, &H47, &H33, &H0, &H0}
         queCommandOutbound.Enqueue(bytG3Query)
      Else
         Dim bytGQuery() As Byte = {&HAA, &HAA, &HFF, &H1, &H0, &H47, &H0, &H0}
         queCommandOutbound.Enqueue(bytGQuery)
      End If
   End Sub ' PostQuery

   Private Function PostRadioResponseInboundData(ByRef bytInboundHostModePacket() As Byte) As Boolean
      ' Receives a byte count inbound host mode packet and posts the data (with the
      ' host mode wrapper removed) to the Pactor control TCP/IP connection...

      Dim bytDataIn(300) As Byte
      Dim intIndex As Integer
      For intIndex = 0 To 300
         If bytInboundHostModePacket(intIndex + 2) = 0 Then Exit For
         bytDataIn(intIndex) = bytInboundHostModePacket(intIndex + 2)
      Next
      ReDim Preserve bytDataIn(intIndex - 1)
      RaiseEvent OnPTCRadio(bytDataIn)
      blnAcknowledged = True
   End Function ' PostRadioResponseInboundData

   Private Sub ProcessDataReceived(ByVal bytReceivedBytes As Byte())
      ' Assembles the received raw data into complete
      ' CRC extended host mode frames...
      Static bytFrame(1000) As Byte
      Static intPosition As Integer
      Static intUpperBound As Integer
      Static blnNullTerminate As Boolean
      Static blnRemoveStuffing As Boolean

      If enmHostState <> HostModeState.HostMode Then
         ProcessNonHostInput(bytReceivedBytes)
      Else
         For Each bytSingle As Byte In bytReceivedBytes
            ' Remove stuffing bytes...
            If intPosition > 2 Then
               If blnRemoveStuffing And bytSingle = 0 Then
                  blnRemoveStuffing = False
                  Continue For
               End If
               blnRemoveStuffing = False
               If bytSingle = &HAA Then
                  blnRemoveStuffing = True
               End If
            End If

            ' Build new frame...
            Select Case intPosition
               Case 0
                  ' First framing byte...
                  If bytSingle = &HAA Then
                     bytFrame(intPosition) = bytSingle
                     intPosition += 1
                     intUpperBound = 0
                     blnNullTerminate = False
                     'blnAcknowledged = False
                  End If
                  blnRemoveStuffing = False
               Case 1
                  ' Second framing byte...
                  If bytSingle = &HAA Then
                     bytFrame(intPosition) = bytSingle
                     intPosition += 1
                  Else
                     intPosition = 0
                  End If
                  blnRemoveStuffing = False
               Case 2
                  ' Channel indicator byte...
                  bytFrame(intPosition) = bytSingle
                  intPosition += 1
               Case 3
                  ' Payload type indicator byte...
                  If bytSingle = 0 Then
                     intUpperBound = 5
                     blnNullTerminate = True
                  ElseIf bytSingle <= 5 Then
                     blnNullTerminate = True
                  End If
                  If bytFrame(2) = &HFF Then
                     If bytSingle = &H0 Then intUpperBound = intPosition + 2
                  End If

                  If bytFrame(2) = &HAA And bytSingle = &H55 Then
                     blnRepeatRequest = True
                     intPosition = 0
                     intUpperBound = 0
                  Else
                     bytFrame(intPosition) = bytSingle
                     intPosition += 1
                  End If
               Case 4
                  ' Payload byte count or start of payload if zero terminated...
                  bytFrame(intPosition) = bytSingle
                  If blnNullTerminate Then
                     If bytSingle = &H0 Then intUpperBound = intPosition + 2
                  Else
                     intUpperBound = CInt(bytSingle) + 7
                  End If
                  intPosition += 1
               Case 5
                  ' Payload or first CRC...
                  If blnNullTerminate Then
                     If bytSingle = &H0 Then intUpperBound = intPosition + 2
                  End If
                  bytFrame(intPosition) = bytSingle
                  If intPosition >= intUpperBound And intUpperBound <> 0 Then
                     If CheckCRC(bytFrame, intPosition) Then
                        ProcessReceivedFrame(bytFrame, intUpperBound)
                        blnAcknowledged = True
                     Else
                        Try
                           objSerial.Write(bytRepeatRequest, 0, 4)
                        Catch
                        End Try
                     End If
                     intPosition = 0
                     intUpperBound = 0
                  Else
                     intPosition += 1
                  End If
               Case 6
                  ' Payload or second CRC...
                  If blnNullTerminate And intUpperBound = 0 Then
                     If bytSingle = &H0 Then intUpperBound = intPosition + 2
                  End If
                  bytFrame(intPosition) = bytSingle
                  If intPosition >= intUpperBound And intUpperBound <> 0 Then
                     If CheckCRC(bytFrame, intPosition) Then
                        ProcessReceivedFrame(bytFrame, intUpperBound)
                        blnAcknowledged = True
                     Else
                        Try
                           objSerial.Write(bytRepeatRequest, 0, 4)
                        Catch
                        End Try
                     End If
                     intPosition = 0
                     intUpperBound = 0
                  Else
                     intPosition += 1
                  End If
               Case Else
                  ' Payload and CRC bytes to intUpperBound...
                  If blnNullTerminate And intUpperBound = 0 Then
                     If bytSingle = &H0 Then intUpperBound = intPosition + 2
                  End If
                  bytFrame(intPosition) = bytSingle
                  If intPosition >= intUpperBound And intUpperBound <> 0 Then
                     If CheckCRC(bytFrame, intUpperBound) Then
                        ProcessReceivedFrame(bytFrame, intUpperBound)
                        blnAcknowledged = True
                     Else
                        Try
                           objSerial.Write(bytRepeatRequest, 0, 4)
                        Catch
                        End Try
                     End If
                     intPosition = 0
                     intUpperBound = 0
                  Else
                     intPosition += 1
                  End If
            End Select
         Next
      End If
   End Sub ' ProcessDataRececeived

   Private Sub ProcessNonHostInput(ByRef bytData() As Byte)
      ' Processes data from the TNC when not in host mode...
      Select Case enmHostState
         Case HostModeState.PTCInitializing
            StartupResponses(bytData)
      End Select
   End Sub ' ProcessNonHostInput

   Private Sub ProcessReceivedFrame(ByRef bytFrame() As Byte, ByVal intUpperBound As Integer)
      ' Processes a host frame received from the TNC... 

      RaiseEvent OnActivity()

      ' Remove the frame leaving the channel number and payload...
      Dim bytPayload(intUpperBound - 4) As Byte
      Array.Copy(bytFrame, 2, bytPayload, 0, intUpperBound - 3)

        Select Case bytPayload(0) ' Select payload type
            Case &HFF
                If bytPayload(2) <> 0 Then
                    Dim intChannel As Integer = CInt(bytPayload(2)) - 1
                    SendHostCommandPacket("G3", CByte(intChannel))
                End If
            Case &HFE ' Status report...
                RaiseEvent OnPTCStatusReport(bytPayload)
            Case &HFD ' From the radio...
                RaiseEvent OnPTCRadio(bytPayload)
            Case Else ' Command responses and channel data...
                Select Case bytPayload(1)
                    Case 1, 2, 3, 4, 6
                        RaiseEvent OnPTCControl(GetString(bytPayload, 2) & vbCr)
                    Case 7
                        RaiseEvent OnPTCData(bytPayload)
                End Select
        End Select
   End Sub ' ProcessReceivedFrame

   Public Sub SendHostCommandPacket(ByVal bytCommand() As Byte, ByVal intChannel As Byte)
      ' Puts a host mode packet in the outbound queue for transmission to the controller...

      If enmHostState = HostModeState.HostMode Then
         Dim bytFrame(bytCommand.Length + 6) As Byte
         bytFrame(0) = &HAA
         bytFrame(1) = &HAA
         bytFrame(2) = intChannel
         bytFrame(3) = 1
         bytFrame(4) = CByte(bytCommand.Length - 1)
         For intIndex As Integer = 5 To bytFrame(4) + 5
            bytFrame(intIndex) = bytCommand(intIndex - 5)
         Next
         queCommandOutbound.Enqueue(bytFrame)
      Else
         Logs.Exception("[SCSHostPort.SendHostPacket] Not in Host mode! State=" & enmHostState.ToString)
      End If
   End Sub ' SendHostPacket (Byte())

   Public Sub SendHostCommandPacket(ByVal strCommand As String, ByVal intChannel As Byte)
      ' Puts a host mode packet in the outbound queue for transmission to the controller...

      If enmHostState = HostModeState.HostMode Then
         Dim bytFrame(strCommand.Length + 6) As Byte
         bytFrame(0) = &HAA
         bytFrame(1) = &HAA
         bytFrame(2) = intChannel
         bytFrame(3) = 1
         bytFrame(4) = CByte(strCommand.Length - 1)
         For intIndex As Integer = 5 To bytFrame(4) + 5
            bytFrame(intIndex) = CByte(Asc(strCommand(intIndex - 5)))
         Next
         queCommandOutbound.Enqueue(bytFrame)
      Else
         Logs.Exception("[SCSHostPort.SendHostPacket] Not in host mode - State=" & _
            enmHostState.ToString & " Command: " & strCommand)
      End If
   End Sub ' SendHostPacket (String)

   Private Sub SendNextFrame(Optional ByVal blnRepeatLast As Boolean = False)
      Static bytPendingFrame() As Byte
      Static intRepeatCount As Integer
      Static blnAlternate As Boolean = True

      If blnRepeatLast = False Then
         intRepeatCount = 0
            If queCommandOutbound.Count > 0 Then
                ' Send a command packet
                Try
                    bytPendingFrame = CType(queCommandOutbound.Dequeue, Byte())
                Catch
                    Return
                End Try
            Else
                ' Send a data packet
                If stcSelectedChannel.ChannelType = EChannelModes.PacketTNC Then
                    ' Packet mode
                    If intTNCFramesPending >= 5 Then
                        '
                        ' Decrease from 7 to 5 to reduce the nuber of uacked buffers in the TNC.
                        ' If we have more than 5 outstanding buffers already sent, stop sending until the TNC
                        ' catches up.
                        '
                        Return
                    Else
                        Try
                            bytPendingFrame = CType(queDataOutbound.Dequeue, Byte())
                        Catch
                            Return
                        End Try
                        UpdateProgressBar(bytPendingFrame.Length - 6)

                    End If
                ElseIf stcSelectedChannel.ChannelType = EChannelModes.PactorTNC Then
                    ' Pactor mode
                    If (intTNCBytesPosted - intTNCBytesSent) > 1200 Then SendHostCommandPacket("%T", 31)
                    PostQuery()
                    Dim intMaxPendingPackets As Integer
                    If stcSelectedChannel.TNCType = "PTC DR-7800" Then
                        intMaxPendingPackets = 20
                    Else
                        intMaxPendingPackets = 10
                    End If
                    If intTNCFramesPending < intMaxPendingPackets + 5 Then    ' PHS
                        ' PHS If (intTNCBytesPosted - intTNCBytesSent) < 2400 Then
                        Try
                            bytPendingFrame = CType(queDataOutbound.Dequeue, Byte())
                        Catch
                            Return
                        End Try
                        intTNCBytesPosted += bytPendingFrame.Length - 7
                    Else
                        Dim intPHS As Integer = intTNCBytesPosted - intTNCBytesSent
                        Return
                    End If
                End If
            End If
         blnAcknowledged = False

         ' Add the alternate frame bit...
         If bytPendingFrame(3) >= &H80 Then blnAlternate = True
         If blnAlternate = True Then bytPendingFrame(3) = bytPendingFrame(3) Or CByte(&H80)
         blnAlternate = Not blnAlternate

         ' Fill in the CRC bytes...
         AddCRC(bytPendingFrame)

         ' Add any required stuffing bytes...
         AddStuffingBytes(bytPendingFrame)

         Try
            objSerial.Write(bytPendingFrame, 0, bytPendingFrame.Length)
         Catch
            End Try
            intTNCFramesPending += 1    ' PHS count another pending outgoing frame (will be updated by L command response)
        Else
            ' Repeat the last command
            blnAcknowledged = False
            intRepeatCount += 1
            If intRepeatCount < 10 Then
                Try
                    objSerial.Write(bytPendingFrame, 0, bytPendingFrame.Length)
                Catch
                End Try
            Else
                queChannelDisplay.Enqueue("R*** No PTC Host mode frame acknowledge after 10 repeats...")
                NewState(HostModeState.PTCFault)
            End If
      End If

   End Sub ' SendNextFrame

   Private Sub StartCRCExtendedHostMode()
      ' Enter CRC extended host mode...
      Try
         objSerial.Write("JHOST4" & vbCr)
      Catch
      End Try
      Thread.Sleep(100)
        NewState(HostModeState.HostMode)

      ' Jump start the polling process...
        Dim bytInitialPoll() As Byte = {&HAA, &HAA, &HFF, &HC1, &H0, &H47, &HF1, &H5F}
        queCommandOutbound.Enqueue(bytInitialPoll)
        SendNextFrame()
   End Sub ' StartCRCExtendedHostMode

   Public Function Startup() As Boolean
      ' Called to handle the initialization and startup proceduce for the PTC controller.

      NewState(HostModeState.PTCInitializing)
      Dim dttTimer As Date

      ' Test if the channel is set up for a fast start...
      Dim blnFastStart As Boolean
      If stcSelectedChannel.TNCConfigureOnFirstUseOnly = True Or blnPactorDialogResuming = True Then
            If cllFastStart.Contains(stcSelectedChannel.ChannelName) Then
                If stcSelectedChannel.TNCType <> "PTC DR-7800" Then ' PHS: DR-7800 requires full initialization
                    blnFastStart = True
                End If
            End If
        End If

        Try
            ' Test for a normal terminal mode command response...
            If IsTNCCommandResponse() = False AndAlso IsTNCCommandResponse(Chr(&H1B)) = False Then
                ' Try and exit host mode strings first in case PTC left in host mode....
                If blnClose Or blnProgramClosing Then Return False
                Try
                    objSerial.Write(bytExitCRCExtendedHostMode, 0, bytExitCRCExtendedHostMode.Length)
                Catch
                End Try
                Thread.Sleep(1000)
                If blnClose Or blnProgramClosing Then Return False
                If IsTNCCommandResponse() = False Then
                    Dim bytExitHostMode() As Byte = {&HAA, &HAA, &H1F, &H1, &H5, &H4A, &H48, &H4F, &H53, &H54, &H30, &H0, &H0}
                    Try
                        objSerial.Write(bytExitHostMode, 0, bytExitHostMode.Length)
                    Catch
                    End Try
                    Thread.Sleep(1000)
                    If blnClose Or blnProgramClosing Then Return False
                    If IsTNCCommandResponse() = False Then
                        ' try clearing KISS mode 
                        Dim bytClearKiss() As Byte = {&HC0, &HFF, &HC0}
                        Try
                            objSerial.Write(bytClearKiss, 0, bytClearKiss.Length)
                        Catch
                        End Try
                        Thread.Sleep(1000)
                        If blnClose Or blnProgramClosing Then Return False
                        If IsTNCCommandResponse() = False Then
                            queChannelDisplay.Enqueue("R*** Could not recover the " & stcSelectedChannel.TNCType & " ... Try power recycle.")
                            Logs.Exception("[SCSHstPort.Startup] Could not recover the " & stcSelectedChannel.TNCType)
                            Return False
                        End If
                    End If
                End If
            End If
            If blnClose Or blnProgramClosing Then Return False
            ' May have been left in packet mode...
            If blnPacSeen Then
                blnCmdSeen = False
                blnAsteriskSeen = False
                ' Resets packet mode if necessary necessary...
                dttTimer = Now
                Try
                    sbdResponse.Length = 0
                    objSerial.Write("QUIT" & vbCr)
                Catch
                End Try
                While Now.Subtract(dttTimer).TotalMilliseconds < 1000
                    Thread.Sleep(100)
                    Poll()
                    If blnClose Or blnProgramClosing Then Return False
                    If (blnCmdSeen Or blnAsteriskSeen) Then Exit While
                End While
            End If
            If blnAsteriskSeen Then ' TNC was left in emulation mode TNC 2 by some other program
                blnCmdSeen = False
                dttTimer = Now
                sbdResponse.Length = 0
                objSerial.Write("TNC 0" & vbCr) ' Put in normal default emulation mode TNC 0
                While Now.Subtract(dttTimer).TotalMilliseconds < 1000
                    Thread.Sleep(100)
                    Poll()
                    If blnClose Or blnProgramClosing Then Return False
                    If blnCmdSeen Then Exit While
                End While
                If Not blnCmdSeen Then
                    queChannelDisplay.Enqueue("R*** Could not recover the TNC from Emulation mode 2")
                    Logs.Exception("[SCSHstPort.Startup] Could not recover the " & stcSelectedChannel.TNCType & " from Emulation mode 2")
                    Return False
                End If
            End If
            ' This should clear any connections . . . does not reset parameters...
            blnCmdSeen = False
            Try
                sbdResponse.Length = 0
                ' PHS objSerial.Write("RESET" & vbCr)
                objSerial.Write("RESTART" & vbCr)   ' PHS DR-7800 works better with Restart than Reset.
            Catch
            End Try
            dttTimer = Now
            While Now.Subtract(dttTimer).TotalMilliseconds < 3000 ' Wait 3 seconds for RESET
                Thread.Sleep(100)
                Poll()
                If blnClose Or blnProgramClosing Then Return False
                If blnCmdSeen Then Exit While
            End While

            ' Attempt to recover the TNC if no "cmd:" has been seen...
            If Not blnCmdSeen Then
                Logs.Exception("[SCSHostPort.Startup] No valid response from " & stcSelectedChannel.TNCType & " after RESET command")
                For intIndex As Integer = 1 To 256
                    Try
                        sbdResponse.Length = 0
                        objSerial.Write(bytSOH, 0, bytSOH.Length)
                    Catch
                    End Try
                    dttTimer = Now.AddMilliseconds(2000)
                    Do
                        If dttTimer < Now Then Exit For
                        Thread.Sleep(100)
                        Poll()
                        If blnClose Or blnProgramClosing Then Return False
                        If blnHostSync Then Exit For
                    Loop
                Next
                Logs.Exception("[SCSHostPort.Startup] " & stcSelectedChannel.TNCType & " Host Sync: " & blnHostSync.ToString)
                Try
                    sbdResponse.Length = 0
                    objSerial.Write(bytExitCRCExtendedHostMode, 0, bytExitCRCExtendedHostMode.Length)
                Catch
                End Try
                Thread.Sleep(500)
                blnCmdSeen = False
                IsTNCCommandResponse()
                If blnClose Or blnProgramClosing Then Exit Function
            End If

            ' Read and send the .aps initialization file if blnFastStart is not set...
            If blnFastStart = False Then
                If blnCmdSeen Then

                    ' Read configuration commands from the configuration file...
                    Dim strLines() As String = File.ReadAllLines(stcSelectedChannel.TNCConfigurationFile)

                    For Each strLine As String In strLines
                        strLine = strLine.Trim
                        If Not strLine.StartsWith(";") Then ' leading ";" comments out line
                            If strLine.IndexOf(";") <> -1 Then
                                strLine = strLine.Substring(0, strLine.IndexOf(";")).Trim ' strip off comments
                            End If
                            If strLine.Length > 0 Then
                                dttTimer = Now
                                blnCmdSeen = False
                                Try
                                    sbdResponse.Length = 0
                                    objSerial.Write(strLine & vbCr)
                                Catch
                                End Try
                                Thread.Sleep(10)
                                Poll()
                            End If
                        End If
                        If blnClose Or blnProgramClosing Then Return False
                    Next
                End If
            End If
            ' Force the MYCALL while in cmd mode
            objSerial.Write("MYCALL " & SiteCallsign & vbCr)
            Thread.Sleep(50)
            objSerial.Write("PAC MYCALL " & SiteCallsign & vbCr)
            Thread.Sleep(50)

            ' Set the TNC to host mode...
            StartCRCExtendedHostMode()

            If cllFastStart.Contains(stcSelectedChannel.ChannelName) = False Then cllFastStart.Add(stcSelectedChannel.ChannelName, stcSelectedChannel.ChannelName)
            Return True
        Catch ex As Exception
            Logs.Exception("[SCSHostPort.Startup] " & ex.Message)
            NewState(HostModeState.PTCFault)
            queChannelDisplay.Enqueue("R*** Error during " & stcSelectedChannel.TNCType & " startup... See error log")
            Return False
        End Try
   End Function ' Startup

   Private Sub StartupResponses(ByVal bytFromPTC() As Byte)
      ' Looks for confirmations to startup commands...

      For Each bytSingle As Byte In bytFromPTC
         If bytSingle <> 0 Then
            'sbdCmdResponse.Append(Chr(bytSingle))
            sbdResponse.Append(Chr(bytSingle))
         End If

         If sbdResponse.ToString.EndsWith("cmd: ") Then
            blnCmdSeen = True
            sbdResponse.Length = 0
         ElseIf sbdResponse.ToString = "* " Then ' this handles case if TNC is in emulation mode TNC 2
            blnAsteriskSeen = True
            sbdResponse.Length = 0
         ElseIf sbdResponse.ToString.EndsWith("pac: ") Then
            blnPacSeen = True
            sbdResponse.Length = 0
         ElseIf sbdResponse.ToString.IndexOf("INVALID") >= 0 Then
            blnHostSync = True
            sbdResponse.Length = 0
         End If
      Next
   End Sub ' StartupResponses
End Class
